import "zod-openapi/extend";
import { z } from "zod";
import userSchema, { UserSchema } from "./generated/zod/modelSchema/UserSchema";

export const idSchema = z.string().uuid();

const SearchFieldEnum = z.enum([
    "name",
    "description",
    "room",
    "structure",
    "cas",
    "producer",
    "catalogId",
    "catalogLink",
]);

// THIS SCHEMA IS USED TILL REPLACEMENT IS FOUND IN AUTOGENERATED SCHEMAS

export const ReagentSearchSchema = z.object({
    query: z
        .string()
        .optional()
        .describe("A search query to filter reagents by name, description, etc."),

    page: z.coerce
        .number()
        .int()
        .positive()
        .default(1)
        .describe("The page number for pagination. Default is 1."),

    limit: z.coerce
        .number()
        .int()
        .positive()
        .max(100)
        .default(10)
        .describe("The number of results per page. Max is 100. Default is 10."),

    sortBy: z
        .enum([
            "name",
            "description",
            "structure",
            "category",
            "quantity",
            "status",
            "expirationDate",
            "storageLocation",
            "cas",
            "producer",
            "catalogId",
            "catalogLink",
            "pricePerUnit",
            "createdAt",
            "updatedAt",
        ])
        .default("name")
        .describe("The field by which the results should be sorted. Default is 'name'."),

    sortOrder: z
        .enum(["asc", "desc"])
        .default("asc")
        .describe("The sort order: 'asc' for ascending, 'desc' for descending. Default is 'asc'."),

    searchBy: z
        .union([
            z.array(SearchFieldEnum), // allows multiple fields for search
            SearchFieldEnum,
        ])
        .transform((val) => (Array.isArray(val) ? val : [val]))
        .optional()
        .describe("Fields to search by. Can be a single value or an array of values."),

    category: z
        .enum(["sample", "reagent"])
        .optional()
        .describe("Filter reagents by category, such as 'sample' or 'reagent'."),
    status: z
        .enum(["available", "lowStock", "outOfStock", "ordered", "notAvailable"])
        .optional()
        .describe(
            "Filter reagents by status. Options include 'available', 'lowStock', 'outOfStock', 'ordered', or 'notAvailable'.",
        ),

    storageLocation: z.string().optional().describe("Filter reagents by their storage location."),
});

export type ReagentSearch = z.infer<typeof ReagentSearchSchema>;

// Enum for searchable fields in storage location search
const StorageLocationFieldEnum = z.enum(["name", "room", "description"]);

// Define the StorageLocationSearch schema
export const StorageLocationSearchSchema = z.object({
    // General search query string (used for searching across all relevant fields).
    query: z.string().optional().describe("A general search term to filter storage locations."),

    // The page number for paginated results.
    page: z.coerce
        .number()
        .int()
        .positive()
        .default(1)
        .describe("The page number for pagination. Default is 1."),

    // The number of items to display per page (with a maximum limit of 100).
    limit: z.coerce
        .number()
        .int()
        .positive()
        .max(100)
        .default(10)
        .describe("The number of results per page. Default is 10, max is 100."),

    // Field by which the results will be sorted.
    sortBy: z
        .enum(["name", "room", "description", "createdAt", "updatedAt"])
        .default("name")
        .describe("The field to sort results by. Default is 'name'."),

    // Order in which results will be sorted (ascending or descending).
    sortOrder: z
        .enum(["asc", "desc"])
        .default("asc")
        .describe(
            "The sort order, either 'asc' for ascending or 'desc' for descending. Default is 'asc'.",
        ),

    // Fields to limit the search scope (can be a single field or multiple fields).
    searchBy: z
        .union([
            z.array(StorageLocationFieldEnum), // Allows selection of multiple fields
            StorageLocationFieldEnum,
        ])
        .transform((val) => (Array.isArray(val) ? val : [val]))
        .optional()
        .describe("Specific fields to search within. Can be a single field or an array of fields."),

    // Filter results by room name or ID.
    room: z.string().optional().describe("Filter results by room name or identifier."),

    // Filter results by the storage location's name.
    name: z.string().optional().describe("Filter results by the name of the storage location."),
});

// Type inference for StorageLocationSearch
export type StorageLocationSearch = z.infer<typeof StorageLocationSearchSchema>;

// New registration schema that includes confirmPassword
export const registerUserSchema = z
    .object({
        username: z
            .string()
            .min(1, {
                message: "Username is required.",
            })
            .max(50, {
                message: "Username must not exceed 50 characters.",
            })
            .refine((val) => val.trim() !== "", {
                message: "Username cannot be empty.",
            }),
        firstName: z.string().min(1, {
            message: "First name is required.",
        }),
        lastName: z.string().min(1, {
            message: "Last name is required.",
        }),
        email: z.string().email({
            message: "Invalid email format.",
        }),
        password: z
            .string()
            .min(8, {
                message: "Password must be at least 8 characters long.",
            })
            .openapi({ example: "password" }),
        confirmPassword: z
            .string()
            .min(8, {
                message: "Confirm password must be at least 8 characters long.",
            })
            .openapi({ example: "confirmPassword" }),
        role: z.enum(["admin", "researcher", "procurementOfficer"], {
            message: "Role must be either admin, researcher  or procurementOfficer.",
        }),
        createdAt: z.coerce.date().optional(),
        updatedAt: z.coerce.date().optional(),
    })
    .refine((data) => data.password === data.confirmPassword, {
        message: "Passwords do not match.",
        path: ["confirmPassword"], // Points the error to the confirmPassword field
    });

// Define the login schema
export const loginUserSchema = z
    .object({
        username: z
            .string()
            .min(1, {
                message: "Username is required.",
            })
            .max(50, {
                message: "Username must not exceed 50 characters.",
            })
            .describe("The username of the user")
            .refine((val) => val.trim() !== "", {
                message: "Username cannot be empty.",
            })
            .openapi({ description: "Username", example: "admin" }),
        password: z
            .string()
            .min(8, {
                message: "Password must be at least 8 characters long.",
            })
            .describe("The user's password")
            .openapi({ description: "User password", example: "password" }),
    })
    .openapi({ ref: "UserLogin" });

export type User = z.infer<typeof userSchema>;

// Type inference for RegisterUser
export type RegisterUser = z.infer<typeof registerUserSchema>;
export type LoginUser = z.infer<typeof loginUserSchema>;

export const updateUserSchema = z.object({
    firstName: z
        .string()
        .min(1, {
            message: "First name is required.",
        })
        .optional(), // Optional for partial updates
    lastName: z
        .string()
        .min(1, {
            message: "Last name is required.",
        })
        .optional(),
    email: z
        .string()
        .email({
            message: "Invalid email format.",
        })
        .optional()
        .default("newEmail@example.com"),
    password: z
        .string()
        .min(8, {
            message: "Password must be at least 8 characters long.",
        })
        .optional()
        .default("newPassword"),
    role: z
        .enum(["admin", "researcher", "procurementOfficer"], {
            message: "Role must be either admin, researcher, or procurementOfficer.",
        })
        .optional(),
});

// Type inference for UpdateUser
export type UpdateUser = z.infer<typeof updateUserSchema>;

export const publicUserSchema = UserSchema.omit({ password: true });
